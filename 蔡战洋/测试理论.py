#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time : 2019/7/12 9:06
# @Author : "Darcy J"
# @Email : cc524997199@163.com
# @File : 测试理论.py

import requests
""""""

"""测试规则"""

# 软件工程 ：使用工程化的思想开发出符合用户需求的过程
# 工程化，系统化，模块化，规范化，可度量化
# 目标：在时间，资源，人员的限制下构建满足用户的需求
# 工程化：系统化（过程），模块化（分工），规范化（有规章制度），可度量化（用数字可表示出来）
# 软件工程的目标：在规定的时间/有限的资源/相应的人员，创造出满足用户需求的软件

# 完整流程
# 开发人员需求：设计出来概要设计（相当于框架，分成几个模块，各个模块有什么样的联系，还有数据库，大概有什么表），然后设计出详细设计（针对某一模块进行详细设计）
# 开发人员进行代码实现，完成后交给测试人员，找软件缺陷（编写测试用例/执行测试/bug 提交跟踪/编写测试报告）
# 质量合格后上线

# 软件的生命周期（重要）
# 1.可行性分析（经济可行性，技术可行性，社会环境因素-->可行性分析报告）
# 2.需求分析（需求规格说明书）
# 3.概要设计（设计软件系统架构，接口，数据库设计-->概要学明书）
# 4.详细设计（设计模块处理逻辑-->详细设计说明书）
# 5.编码（编写源代码）
# 6.测试（对比实际效果和预期效果是否一致）
# 7.运维

# 软件开发模型，瀑布模型，增量模型，迭代模型，原型模型，螺旋模型，v模型，w模型，二八原则，pdca，smart原则,5w2h

# 项目：在有限时间和资源（人力/财力/物力）限制下，为达到某一特定的目标，而做的一系列活动的集合（项目不是目标）（）



"""软件测试"""
# 软件测试：使用专用方法，手段和工具检测软件是否符合用户需求过程
# 使用人工或者自动的手段来运行或测定某个软件系统的过程，使其在于检验他是否满足规定的需求或弄清预期结果与实际结果之间的差别
# 软件测试的目的：找出软件存在的缺陷，检查软件是否符合用户需求
# 质量：产品或服务符合用户需求的程度


"""CMMI等级"""
# cmmi被开发出来的目的：对软件过程进行管理改进，从而按时地，不超预算的开发出高质量的软件
# cmmi：软件能力成熟度集成模型：
# 一级：初始级 二级：可管理级 三级：已定义级 四级：量化管理级 五级：优化管理级



"""测试分类"""

# 1.按照测试阶段划分：
# 单元测试：测试源代码是否符合编程规范，处理逻辑正确——通常开发人员测试（白盒测试工程师）
# 集成测试：测试模块与模块之间接口，子系统与子系统之间接口——通常测试人员测试（）
# 系统测试：测试软件系统（包括硬件，软件，网络，用户）是否符合用户需求——通常测试人员测试（）
# 验收测试：测试软件系统——通常用户自测

# 2.按照测试方法划分：
# 黑盒测试：把测试对象当作一个不透明的盒子，只关注输入数据和输出结果
# 白盒测试：把测试对象当作一个透明的盒子，关注代码结构和处理逻辑
# 灰盒测试：介于两者之间

# 3.按照是否执行程序划分
# 静态测试：测试文档（需求文档，设计文档，用户手册等），代码内容
# 动态测试：执行程序的测试

# 4.按照是否使用自动化工具划分
# 手工测试：手动进行测试
# 自动化测试：使用机器（包括自动化，代码）进行测试

# 5.按照测试实施方划分
# Alpha测试：用户在开发公司人员陪同下，使用开发环境进行测试
# Bate测试：用户在生产环境进行测试
# 第三方测试：用户委托甲方和乙方外的其他公司进行测试

# 6.按照测试对象划分
# 功能测试，性能测试，安全测试，兼容性测试，ui测试，可靠性测试，容错性测试，安装卸载测试，接口测试，场景测试

# 7.其他类型
# 回归测试：验证bug是否修复：再次执行失败的用例
# 冒烟测试：进行详细测试之前，检查重要功能是否可用
# 探索性测试：他是一种经过深思熟虑的测试方式，没有测试脚本，可以使你的测试超出各种明显已经测试过的场景
# 随机测试：在对软件足够了解之后，随意测


""" 软件测试工程师的职业素质"""
# 细心，耐心，自信心，责任心，专心
# 要相信任何软件都存在缺陷（具有怀疑精神）
# 具备逻辑分析能力
# 具备团队合作精神
# 具备较好的沟通交集能力
# 具备编程能力
# 实事求是（不要夸大问题，不要虚报问题）
# 不断总结经验教训，不断学习专业知识
# 有原则
# 缺陷无论大小都要报告，不可重现的缺陷也要报告


"""测试对象"""
# 需求规格说明书
# 概要设计说明书
# 详细设计说明书
# 代码
# 用户手册
# 维护手册
# 注意：测试文档维度：1.完整性（不要遗漏需求）2.歧义性 3.规范性 4.合理性 5.可测试性


"""测试产物"""
# 1.测试需求
# 2.测试计划
# 3.测试策略
# 4.测试用例
# 5.缺陷报告
# 6.测试报告


"""软件测试流程"""
# 1.需求熟悉与确认         7.冒烟测试
# 2.指定测试计划           8.执行测试用例
# 3.评审测试计划           9.提交并跟踪bug
# 4.编写测试用例           10.回归测试
# 5.评审测试用例           11.编写测试报告
# 6.准备搭建测试环境       12.总结项目经验教训


"""测试用例组成"""
# 1.测试编号
# 2.测试点（测试用例标题）
# 3.前置条件
# 4.测试步骤
# 5.预期结果
# 6.执行结果
# 7.优先级
# 8.备注
# 9.测试类型等


"""为什么要写测试用例"""
# 理清思路，避免遗漏
# 便于跟进测试进度
# 历史参考
# 可重复使用

# 优点：
# 1、把产品需求转换为一种可操作的步骤，方便以后有步骤有计划的进行测试。
# 2、验证产品的需求是否合理
# 3、监督产品对需求做出更加详细的设计
# 4、记录产品的设计细节，保障以后的查阅
# 5、加深测试人员对产品的认识和印象
# 6、反应测试进度
# 7、帮助发现拓展测试范围，扩大测试覆盖面，发现软件中潜藏的缺陷
# 8、方便回归测试，复查bug是否还会出现
# 9、为紧急情况下的测试提供参考信息
# 10、培训新人，提高新人测试效率，节省对新人的指导时间
# 缺点：
# 1、增加了测试的维护成本
# 2、消耗了时间成本


"""测试用例"""
# 定义：为了某一目的（验证软件的特性是否符合需求）而编写一组包含测试执行条件，测试输入和预期结果等的集合


"""好的测试用例具备条件"""
# 1.能够高效的发现软件中的缺陷
# 2.测试用例覆盖程度高
# 3.测试用例设计和执行成本小
# 4.冗余度小，可重复性小
# 5.易于维护


"""测试用例管理软件"""
# excel表格
# testlink
# 禅道
# testdirector（TD）
# xmind(思维导图)


"""编写测试用例的途径"""
# 根据需求设计写测试用例
# 通过bug反推，修改补充测试用例


"""测试缺陷"""
# bug，defect
# 定义：软件中存在的实际结果和预期结果之间的偏差
# bug报告单的组成：bugid，bug标题，bug描述，严重级别，优先级，功能模块，bug状态，复现步骤，附件，备注，测试版本


"""为什么要有测试报告单"""
# 能够清晰准确有条理将软件中的缺陷描述出来，便于开发人员理解
# 加快缺陷修复的速度
# 便于质量控制
# 能够衡量测试人员的工作能力


"""好的缺陷报告单"""
# 内容准确，内容清晰，步骤简洁，结构完整，风格一致


"""bug管理工具"""
# 禅道，jira，mantis，bugzilla，redmine


"""缺陷分类"""
# 分类一：代码错误，设计缺陷，界面优化，配置相关，安装部署，性能问题，标准规范
# 分类二：功能类，性能类，界面类，易用性类，兼容性类，其他


"""缺陷严重级别"""
# 致命，严重，一般，轻微，建议


"""测试用例设计方法"""
# 等价类划分，边界值分析，场景法 ，错误猜测法（黑盒测试）

# 等价类划分用少量测试用例就能覆盖较大的输入域， 大大降低测试用例的数量。
# 等价类划分法使我们更加了解测试用例覆盖的输入域
# 等价类划分适合如下情况：在一个集合下有多个数值， 系统对该集合中每个数值的处理方式都相同。 对于如何处理集合中的每个数值，最简单的方式就直接 询问开发人员是如何实现的。
# 等价类划分通常基于需求将输入域划分为多个等价类。
# 等价类划分可适用于单元、集成、系统和验收测

# 等价类划分法是从某等价类中随便挑一个作为代表。
# 边界值分析是使这个等价类的每个边界都要作为测 试条件

# 确定基本流和备选流
# ① 绘制流程图
# 确定场景
# 生成相应的测试用例
# 为每一个测试用例确定测试数据


"""测试结束的标准"""
# 全部测试用例回归测试都执行完成
# 未修改bug都被确认或置为应有状态，暂缓修改的问题都有的详尽的解释
# 测试报告编写完成
# 测试工作收尾结束
# 测试总结完成
# 项目处于试运行或上线阶段
# 测试活动没有尽头，只有相对完成



# import pyperclip
# pyperclip.copy('hello world')  #复制
# print(pyperclip.paste())   #粘贴
# os.startfile(r'D:\Users\Darcy\AppData\Local\Youdao\Dict\YoudaoDict.exe')

# url_moves=requests.get('ftp://ygdy8:ygdy8@yg45.dydytt.net:8476/阳光电影www.ygdy8.com.T-34坦克.BD.720p.俄语中字.mkv',stream=True)
#with open('a.mp4','wb') as  fc:
#     fc.write(url_moves.content)
# print('ok')


#
# class gh(threading.Thread):
#     def __init__(self,id,name,num):
#         threading.Thread.__init__(self)
#     def run(self):
#         a=1454433242
#         b=0
#         while a!=b:
#             b+=1
#             print(b)
#
# kl=gh('op', "Thread-1", 1)
# kj=gh('opp','thoi',2)
# kl.start()
# kj.start()
# kl.join()
# kj.join()

# from __future__ import division
# import sys,time
# j = '#'
# if __name__ == '__main__':
#   for i in range(1,61):
#     j += '#'
#     sys.stdout.write(str(int((i/60)*100))+'% '+j+'->'+ "\r")
#     sys.stdout.flush()
#     time.sleep(0.5)
# print()

import  socket,threading
class client(object):
    def __init__(self):
        ip_port = ('127.0.0.1', 9789)  # 指定客服端ip，端口号
        self.c = socket.socket()  # 创建套接字，接收服务器发送的数据
        self.c.connect(ip_port)  # 连接服务器
        # 发送数据到服务器，接收服务器数据
        # t = input('输入发送数据：')
        # 发送
        # c.sendall(t.encode())   #发送所有数据到服务器 :sendall() encode()编码方式发送二进制
    def clientmsg(self):
        while True:
            t = input('请输入发送服务端内容:')
            # print(threading.active_count())
            if t == "1":
                print('关闭服务端')
                break
            else:
                # print("客服端向服务器发送的信息")
                self.c.sendall(t.encode())
                # a1 = c.recv(1024).decode('utf-8')
                # print(a1)
        self.c.close()
    def clientsed(self):
        # ip_port = ('127.0.0.1', 9789)  # 指定客服端ip，端口号
        # c = socket.socket()  # 创建套接字，接收服务器发送的数据
        # c.connect(ip_port)  # 连接服务器
        # 发送数据到服务器，接收服务器数据
        # t = input('输入发送数据：')
        # 发送
        # c.sendall(t.encode())   #发送所有数据到服务器 :sendall() encode()编码方式发送二进制
        while True:
            # t = input('请输入发送服务端内容:')
            a1 = self.c.recv(1024).decode('utf-8')
            if a1 == "1":
                print('关闭服务端')
                break
            else:
                # print("客服端向服务器发送的信息")
                # c.sendall(t.encode())
                print(a1)
        self.c.close()


def main():
    ty=client()
    t=threading.Thread(target=ty.clientmsg)
    t1=threading.Thread(target=ty.clientsed,name='T1')
    t.start()
    t1.start()

if __name__ == '__main__':
    main()


